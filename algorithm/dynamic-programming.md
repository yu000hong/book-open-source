# 动态规划算法

将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。

### 相关概念

**无后效性**

如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响，也即**未来与过去无关**，这就是`无后效性`。

**重叠子结构**

动态规划是将一个多阶段问题分成几个相互联系的单阶段问题，而这几个相互联系的单阶段问题一定要是一族同类型的子问题，这样分成多阶段决策才是有意义的，否则我们每次面对的决策都是不同的问题，也就失去了分成单阶段的意义。

在算法上，我们把这种同类型的子问题又叫做**重叠子结构**。重叠不是相同，而是同类型，我们必须得利用前面子结构计算出的结果，用递推不断地调用同一个问题。

**最优子结构**

大问题的最优解可以由小问题的最优解推出，这个性质叫做`最优子结构`性质。

> 引入这三个概念之后，我们如何判断一个问题能否使用DP解决呢？
>
> 能将大问题拆成几个小问题，且满足无后效性、重叠子结构、最优子结构性质。

### 核心思想

无论是动态规划还是暴力求解，我们的算法都是在可能解空间内，寻找最优解。来看钞票问题。暴力做法是枚举所有的可能解，这是最大的可能解空间。动态规划是枚举有希望成为答案的解。这个空间比暴力的小得多，也就是说：**动态规划自带剪枝**。DP舍弃了一大堆不可能成为最优解的答案。从而我们可以得到DP的核心思想：**尽量缩小可能解空间**。　　

在暴力算法中，可能解空间往往是指数级的大小；如果我们采用DP，那么有可能把解空间的大小降到多项式级。一般来说，解空间越小，寻找解就越快，这样就完成了优化。

### 动态规划本质

动态规划的本质是通过**拆分问题**，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。也就是说如何拆分问题，才是动态规划的核心。而拆分问题，靠的就是**状态的定义**和**状态转移方程**的定义。

### 解题三大步骤

动态规划，无非就是利用历史记录，来避免我们的重复计算。而这些历史记录，我们得需要一些变量来保存，一般是用**一维数组**或者**二维数组**来保存。

> **第一步骤**：定义数组元素的含义，其实就是`状态的定义`。上面说了，我们会用一个数组，来保存历史数组，假设用一维数组 dp[] 吧。这个时候有一个非常非常重要的点，就是规定你这个数组元素的含义，例如你的 dp[i] 是代表什么意思。

> **第二步骤**：找出数组元素之间的关系式，其实就是`状态转移方程的定义`。我觉得动态规划，还是有一点类似于我们高中学习时的归纳法的，当我们要计算 dp[n] 时，是可以利用 dp[n-1]，dp[n-2].....dp[1]，来推出 dp[n] 的，也就是可以利用历史数据来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，这个就是他们的关系式了。而这一步，也是最难的一步。

> **第三步骤**：找出初始值。学过数学归纳法的都知道，虽然我们知道了数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，我们可以通过 dp[n-1] 和 dp[n-2] 来计算 dp[n]，但是，我们得知道初始值啊，例如一直推下去的话，会由 dp[3] = dp[2] + dp[1]。而 dp[2] 和 dp[1] 是不能再分解的了，所以我们必须要能够直接获得 dp[2] 和 dp[1] 的值，而这就是所谓的初始值。由了初始值，并且有了数组元素之间的关系式，那么我们就可以得到 dp[n] 的值了，而 dp[n] 的含义是由你来定义的，你想求什么，就定义它是什么，这样，这道题也就解出来了。


### 常用案例

- 01背包问题
- 凑零钱问题
- DAG最短路径问题
- 最长上升子序列
- 最大子序和
- 编辑距离(难)
- 鸡蛋掉落(难)

### 参考资源

[什么是动态规划（Dynamic Programming）？动态规划的意义是什么？](https://www.zhihu.com/question/23995189)