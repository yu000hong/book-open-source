# 递推与递归

### 概念

**递归**

从所需结果出发不断回溯前一运算直到回到初值再递推得到所需结果。从未知到已知，从大到小，再从小到大回归。如果递归的N值太大层级太深的话，容易导致栈空间会不够用。

**递推**

从初值出发反复进行一运算得到所需结果。从已知到未知，从小到大。

```js
//斐波那契数列举例

//递归求解
function fib(n){
    return n<2 ? 1 : fib(n-1) + fib(n-2);
}
//递推求解
function fib(n){
    let fn1 = 0;
    let fn2 = 0;
    let fn = 1;
    for (let i=1; i<n; i++) {
        fn1 = fn2;
        fn2 = fn;
        fn = fn1 + fn2;
    }
    return fn;
}
```

### 递归

**线形递归**

```js
function sum(n){
    return n <= 1 ? 1 : n+sum(n-1);
}
```

**树形递归**

```js
function fib(n){
    return n<2 ? 1 : fib(n-1) + fib(n-2);
}
```

### 递归优化

当在使用递归解决问题的时候，要考虑以下两个问题：

- **记忆性递归**：是否有状态重复计算的，可不可以使用备忘录法来优化
- **尾递归**：是否可以采用尾递归避免调用栈OOM，是否可以考虑采用迭代的方式去做

```java
int[] result = new int[1000];
public int f(int n) {
    if (n <= 2) {
        return n;
    } else {
        if (result[n] != 0) {
            return result[n];//已经计算过，直接返回，避免重复
        } else {
            result[n] = f(n-1) + f(n-2);
            return result[n];
        }
    }
}
```

> C语言对尾递归有优化，可以避免调用栈OOM。但有些语言不支持尾递归优化，比如Java/Python，因为优化之后会导致调用栈错乱，没法有效定位问题。所有的尾递归都可以转换成迭代的方式，所以只要能写成尾递归的形式，即使语言层面不支持尾递归优化，我们也能容易的转换成迭代的方式。

### 尾调用

尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。

```js
function f(x){
  return g(x);
}
```

以下两种情况都不属于尾调用：

```js
// 情况一
function f(x){
  let y = g(x);
  return y;
}
// 情况二
function f(x){
  return g(x) + 1;
}
```

尾调用不一定出现在函数尾部，只要是最后一步操作即可。

```js
//m和n都属于尾调用
function f(x) {
  if (x > 0) {
    return m(x)
  }
  return n(x);
}
```

> **尾调用优化**: 尾调用之所以与其他调用不同，就在于它的特殊的调用位置。我们知道，函数调用会在内存形成一个"调用记录"，又称"调用帧"（call frame），保存调用位置和内部变量等信息。所有的调用记录，就形成一个"调用栈"（call stack）。尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。
> 
> 如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是"尾调用优化"的意义。

### 尾递归

函数调用自身，称为递归。如果尾调用自身，就称为尾递归。递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生"栈溢出"错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生"栈溢出"错误。

> 尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是**把所有用到的内部变量改写成函数的参数**。

总结一下，递归本质上是一种循环操作。**纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现**，这就是为什么尾递归对这些语言极其重要。对于其他支持"尾调用优化"的语言（比如Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。

### 参考资源

[尾调用优化](http://www.ruanyifeng.com/blog/2015/04/tail-call.html)



